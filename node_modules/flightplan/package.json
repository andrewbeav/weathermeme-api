{
  "_args": [
    [
      {
        "raw": "flightplan",
        "scope": null,
        "escapedName": "flightplan",
        "name": "flightplan",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/run/media/andrewbeav/My Files/home/Documents/code/projects/weathermeme-api"
    ]
  ],
  "_from": "flightplan@latest",
  "_id": "flightplan@0.6.17",
  "_inCache": true,
  "_location": "/flightplan",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/flightplan-0.6.17.tgz_1496655434332_0.05088539840653539"
  },
  "_npmUser": {
    "name": "pstadler",
    "email": "patrick.stadler@gmail.com"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {
    "abbrev": "1.1.0"
  },
  "_requested": {
    "raw": "flightplan",
    "scope": null,
    "escapedName": "flightplan",
    "name": "flightplan",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#DEV:/",
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/flightplan/-/flightplan-0.6.17.tgz",
  "_shasum": "c0a0547d89648cdcccdc9e7ef260a74e1a8987ee",
  "_shrinkwrap": null,
  "_spec": "flightplan",
  "_where": "/run/media/andrewbeav/My Files/home/Documents/code/projects/weathermeme-api",
  "author": {
    "name": "Patrick Stadler",
    "email": "patrick.stadler@gmail.com"
  },
  "bin": {
    "fly": "./bin/fly.js"
  },
  "bugs": {
    "url": "https://github.com/pstadler/flightplan/issues"
  },
  "dependencies": {
    "byline": "^4.2.1",
    "chalk": "^1.1.1",
    "fibers": "1.0.15",
    "interpret": "^1.0.0",
    "liftoff": "^2.2.0",
    "nopt": "^3.0.4",
    "pretty-hrtime": "^1.0.1",
    "prompt": "^0.2.14",
    "semver": "^5.1.0",
    "ssh2": "^0.4.15",
    "util-extend": "^1.0.1",
    "v8flags": "^2.0.10"
  },
  "description": "Library for streamlining application deployment or systems administration tasks",
  "devDependencies": {
    "chai": "^3.3.0",
    "coveralls": "^2.11.4",
    "eslint": "^1.10.3",
    "istanbul": "^0.4.0",
    "markdox": "^0.1.10",
    "mocha": "^2.3.3",
    "pre-commit": "^1.1.1",
    "proxyquire": "^1.7.3",
    "sinon": "^1.17.2"
  },
  "directories": {},
  "dist": {
    "shasum": "c0a0547d89648cdcccdc9e7ef260a74e1a8987ee",
    "tarball": "https://registry.npmjs.org/flightplan/-/flightplan-0.6.17.tgz"
  },
  "gitHead": "0c5b90bd07d5add4d700058b3672ceacdf599128",
  "homepage": "https://github.com/pstadler/flightplan",
  "keywords": [
    "deploy",
    "deployment",
    "commands",
    "devops",
    "exec",
    "shell",
    "bash",
    "ssh",
    "tasks",
    "parallel",
    "sequential",
    "remote",
    "local",
    "cloud",
    "fabric"
  ],
  "license": "MIT",
  "maintainers": [
    {
      "name": "pstadler",
      "email": "patrick.stadler@gmail.com"
    }
  ],
  "name": "flightplan",
  "optionalDependencies": {},
  "pre-commit": [
    "lint"
  ],
  "readme": "# Flightplan\n\n[![NPM version][npm-version-image]][npm-url] [![Build Status][build-status-image]][build-status-url]\n[![Build Status][coverage-image]][coverage-url] [![NPM downloads][npm-downloads-image]][npm-url] [![Dependency Status][dependencies-image]][dependencies-url]\n\nRun sequences of shell commands against local and remote hosts.\n\nFlightplan is a [node.js](http://nodejs.org) library for streamlining application deployment or systems administration tasks.\n\nA complete list of changes can be found in the [Changelog](https://github.com/pstadler/flightplan/releases).\n\n**Looking for help / maintainers:** See [#162](https://github.com/pstadler/flightplan/issues/162).\n\n## Installation & Usage\n\n```bash\n# install the cli tool\n$ npm install -g flightplan\n\n# use it in your project\n$ npm install flightplan --save-dev\n\n# run a flightplan (`fly --help` for more information)\n$ fly [task:]<target> [--flightplan flightplan.(js|coffee)]\n```\n\nBy default, the `fly` command will try to load `flightplan.js` or `flightplan.coffee`.\n\n## Sample flightplan.js\n\n```javascript\n// flightplan.js\nvar plan = require('flightplan');\n\n// configuration\nplan.target('staging', {\n  host: 'staging.example.com',\n  username: 'pstadler',\n  agent: process.env.SSH_AUTH_SOCK\n});\n\nplan.target('production', [\n  {\n    host: 'www1.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  },\n  {\n    host: 'www2.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  }\n]);\n\nvar tmpDir = 'example-com-' + new Date().getTime();\n\n// run commands on localhost\nplan.local(function(local) {\n  local.log('Run build');\n  local.exec('gulp build');\n\n  local.log('Copy files to remote hosts');\n  var filesToCopy = local.exec('git ls-files', {silent: true});\n  // rsync files to all the target's remote hosts\n  local.transfer(filesToCopy, '/tmp/' + tmpDir);\n});\n\n// run commands on the target's remote hosts\nplan.remote(function(remote) {\n  remote.log('Move folder to web root');\n  remote.sudo('cp -R /tmp/' + tmpDir + ' ~', {user: 'www'});\n  remote.rm('-rf /tmp/' + tmpDir);\n\n  remote.log('Install dependencies');\n  remote.sudo('npm --production --prefix ~/' + tmpDir\n                            + ' install ~/' + tmpDir, {user: 'www'});\n\n  remote.log('Reload application');\n  remote.sudo('ln -snf ~/' + tmpDir + ' ~/example-com', {user: 'www'});\n  remote.sudo('pm2 reload example-com', {user: 'www'});\n});\n\n// run more commands on localhost afterwards\nplan.local(function(local) { /* ... */ });\n// ...or on remote hosts\nplan.remote(function(remote) { /* ... */ });\n```\n\n# Documentation\n\n<!-- DOCS -->\n\n<!-- Start ../lib/index.js -->\n\n## Flightplan\n\nA flightplan is a set of subsequent flights to be executed on one or more\nhosts. Configuration is handled with the `target()` method.\n\n```javascript\nvar plan = require('flightplan');\n```\n\n### Flights\nA flight is a set of commands to be executed on one or more hosts. There are\ntwo types of flights:\n\n#### Local flights\n\nCommands in local flights are executed on the **localhost**.\n\n```javascript\nplan.local(function(transport) {\n  transport.hostname(); // prints the hostname of localhost\n});\n```\n\n#### Remote flights\n\nCommands in remote flights are executed in **parallel** against remote hosts.\n\n```javascript\nplan.remote(function(transport) {\n  transport.hostname(); // prints the hostname(s) of the remote host(s)\n});\n```\n\nYou can define multiple flights of each type. They will be executed in the\norder of their definition. If a previous flight failed, all subsequent\nflights won't get executed. For more information about what it means for\na flight to fail, see the section about `Transport`.\n\n```javascript\n// executed first\nplan.local(function(transport) {});\n\n// executed if first flight succeeded\nplan.remote(function(transport) {});\n\n// executed if second flight succeeded\nplan.local(function(transport) {});\n\n// ...\n```\n\n### Tasks\nFlightplan supports optional tasks to run a subset of flights.\n\n```javascript\n// fly deploy:<target>\nplan.local('deploy', function(transport) {});\n\n// fly build:<target>\nplan.local('build', function(transport) {});\n\n// fly deploy:<target> or...\n// fly build:<target>\nplan.local(['deploy', 'build'], function(transport) {});\nplan.remote(['deploy', 'build'], function(transport) {});\n```\n\nIf no task is specified it's implicitly set to \"default\". Therefore,\n`fly <target>` is the same as `fly default:<target>`.\n\n```javascript\n// fly <target>\nplan.local(function(transport) {});\n// is the same as...\nplan.local('default', function(transport) {});\n// \"default\" + other tasks:\nplan.remote(['default', 'deploy', 'build'], function(transport) {});\n```\n\n### flightplan.target(name, hosts[, options]) → this\n\nConfigure the flightplan's targets with `target()`. Without a\nproper setup you can't do remote flights which require at\nleast one remote host. Each target consists of one or more hosts.\n\nValues in the hosts section are passed directly to the `connect()`\nmethod of [mscdex/ssh2](https://github.com/mscdex/ssh2#connection-methods)\nwith one exception: `privateKey` needs to be passed as a string\ncontaining the path to the keyfile instead of the key itself.\n\n```javascript\n// run with `fly staging`\nplan.target('staging', {\n  // see: https://github.com/mscdex/ssh2#connection-methods\n  host: 'staging.example.com',\n  username: 'pstadler',\n  agent: process.env.SSH_AUTH_SOCK\n});\n\n// run with `fly production`\nplan.target('production', [\n  {\n    host: 'www1.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  },\n  {\n    host: 'www2.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  }\n]);\n\n// run with `fly dynamic-hosts`\nplan.target('dynamic-hosts', function(done, runtime) {\n  var AWS = require('aws-sdk');\n  AWS.config.update({accessKeyId: '...', secretAccessKey: '...'});\n  var ec2 = new AWS.EC2();\n  var params = {Filters: [{Name: 'instance-state-name', Values: ['running']}]};\n  ec2.describeInstances(params, function(err, response) {\n    if(err) {\n      return done(err);\n    }\n    var hosts = [];\n    response.data.Reservations.forEach(function(reservation) {\n      reservation.Instances.forEach(function(instance) {\n        hosts.push({\n          host: instance.PublicIpAddress,\n          username: 'pstadler',\n          agent: process.env.SSH_AUTH_SOCK\n        });\n      });\n    });\n    done(hosts);\n  });\n});\n```\n\nUsually flightplan will abort when a host is not reachable or authentication\nfails. This can be prevented by setting a property `failsafe` to `true` on\nany of the host configurations:\n\n```javascript\nplan.target('production', [\n  {\n    host: 'www1.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  },\n  {\n    host: 'www2.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK,\n    failsafe: true // continue flightplan even if connection to www2 fails\n  }\n]);\n```\n\nYou can override the `username` value of hosts by calling `fly` with\nthe `-u|--username` option:\n\n```bash\nfly production --username=admin\n```\n\n#### Configuring remote hosts during runtime (e.g. using AWS/EC2)\n\nInstead of having a static hosts configuration for a target you can configure\nit on the fly by passing a function `fn(done)` as the second argument to\n`target()`.\n\nThis function is exectued at the very beginning. Whatever is passed to\n`done()` will be used for connecting to remote hosts. This can either be an\nobject or an array of objects depending on if you want to connect to one or\nmultiple hosts. Passing an `Error` object will immediately abort the current\nflightplan.\n\n```javascript\nplan.target('dynamic-hosts', function(done, runtime) {\n  var AWS = require('aws-sdk');\n  AWS.config.update({accessKeyId: '...', secretAccessKey: '...'});\n  var ec2 = new AWS.EC2();\n  var params = {Filters: [{Name: 'instance-state-name', Values: ['running']}]};\n  ec2.describeInstances(params, function(err, response) {\n    if(err) {\n      return done(err);\n    }\n    var hosts = [];\n    response.data.Reservations.forEach(function(reservation) {\n      reservation.Instances.forEach(function(instance) {\n        hosts.push({\n          host: instance.PublicIpAddress,\n          username: 'pstadler',\n          agent: process.env.SSH_AUTH_SOCK\n        });\n      });\n    });\n    done(hosts);\n  });\n});\n```\n\n#### Defining and using properties depending on the target\n\n`target()` takes an optional third argument to define properties used by\nthis target. Values defined in this way can be accessed during runtime.\n\n```javascript\nplan.target('staging', {...}, {\n  webRoot: '/usr/local/www',\n  sudoUser: 'www'\n});\n\nplan.target('production', {...}, {\n  webRoot: '/home/node',\n  sudoUser: 'node'\n});\n\nplan.remote(function(remote) {\n  var webRoot = plan.runtime.options.webRoot;   // fly staging -> '/usr/local/www'\n  var sudoUser = plan.runtime.options.sudoUser; // fly staging -> 'www'\n  remote.sudo('ls -al ' + webRoot, {user: sudoUser});\n});\n```\n\nProperties can be set and overwritten by passing them as named options to the\n `fly` command.\n\n```bash\n$ fly staging --sudoUser=foo\n# plan.runtime.options.sudoUser -> 'foo'\n```\n\n### flightplan.local([tasks, ]fn) → this\n\nCalling this method registers a local flight. Local flights are\nexecuted on your localhost. When `fn` gets called a `Transport` object\nis passed with the first argument.\n\n```javascript\nplan.local(function(local) {\n  local.echo('hello from your localhost.');\n});\n```\n\nAn optional first parameter of type Array or String can be passed for\ndefining the flight's task(s).\n\n### flightplan.remote([tasks, ]fn) → this\n\nRegister a remote flight. Remote flights are executed on the current\ntarget's remote hosts defined with `target()`. When `fn` gets called\na `Transport` object is passed with the first argument.\n\n```javascript\nplan.remote(function(remote) {\n  remote.echo('hello from the remote host.');\n});\n```\n\nAn optional first parameter of type Array or String can be passed for\ndefining the flight's task(s).\n\n### flightplan.abort([message])\n\nManually abort the current flightplan and prevent any further commands and\nflights from being executed. An optional message can be passed which\nis displayed after the flight has been aborted.\n\n```javascript\nplan.abort('Severe turbulences over the atlantic ocean!');\n```\n\n<!-- End ../lib/index.js -->\n\n<!-- Start ../lib/transport/index.js -->\n\n## Transport\n\nA transport is the interface you use during flights. Basically they\noffer you a set of methods to execute a chain of commands. Depending on the\ntype of flight, this is either a `Shell` object for local\nflights, or an `SSH` for remote flights. Both transports\nexpose the same set of methods as described in this section.\n\n```javascript\nplan.local(function(local) {\n  local.echo('Shell.echo() called');\n});\n\nplan.remote(function(remote) {\n  remote.echo('SSH.echo() called');\n});\n```\n\nWe call the Transport object `transport` in the following section to avoid\nconfusion. However, do yourself a favor and use `local` for local, and\n`remote` for remote flights.\n\n#### Accessing runtime information\n\nFlightplan provides information during flights with the `runtime` properties:\n\n```javascript\nplan.remote(function(transport) { // applies to local flights as well\n  // Flightplan specific information\n  console.log(plan.runtime.task);    // 'default'\n  console.log(plan.runtime.target);  // 'production'\n  console.log(plan.runtime.hosts);   // [{ host: 'www1.example.com', port: 22 }, ...]\n  console.log(plan.runtime.options); // { debug: true, ... }\n\n  // Flight specific information\n  console.log(transport.runtime); // { host: 'www1.example.com', port: 22 }\n});\n```\n\n### transport.exec(command[, options]) → code: int, stdout: String, stderr: String\n\nTo execute a command you have the choice between using `exec()` or one\nof the handy wrappers for often used commands:\n`transport.exec('ls -al')` is the same as `transport.ls('-al')`. If a\ncommand returns a non-zero exit code, the flightplan will be aborted and\nall subsequent commands and flights won't get executed.\n\n#### Options\nOptions can be passed as a second argument. If `failsafe: true` is\npassed, the command is allowed to fail (i.e. exiting with a non-zero\nexit code), whereas `silent: true` will simply suppress its output.\n\n```javascript\n// output of `ls -al` is suppressed\ntransport.ls('-al', {silent: true});\n\n// flightplan continues even if command fails with exit code `1`\ntransport.ls('-al foo', {failsafe: true}); // ls: foo: No such file or directory\n\n// both options together\ntransport.ls('-al foo', {silent: true, failsafe: true});\n```\n\nTo apply these options to multiple commands check out the docs of\n`transport.silent()` and `transport.failsafe()`.\n\n#### Return value\nEach command returns an object containing `code`, `stdout` and`stderr`:\n\n```javascript\nvar result = transport.echo('Hello world');\nconsole.log(result); // { code: 0, stdout: 'Hello world\\n', stderr: null }\n```\n\n#### Advanced options\nFlightplan uses `child_process#exec()` for executing local commands and\n`mscdex/ssh2#exec()` for remote commands. Options passed with `exec` will\nbe forwarded to either of these functions.\n\n```javascript\n// increase maxBuffer for child_process#exec()\nlocal.ls('-al', {exec: {maxBuffer: 2000*1024}});\n\n// enable pty for mscdex/ssh2#exec()\nremote.ls('-al', {exec: {pty: true}});\n```\n\n### transport.sudo(command[, options]) → code: int, stdout: String, stderr: String\n\nExecute a command as another user with `sudo()`. It has the same\nsignature as `exec()`. Per default, the user under which the command\nwill be executed is \"root\". This can be changed by passing\n`user: \"name\"` with the second argument:\n\n```javascript\n// will run: echo 'echo Hello world' | sudo -u root -i bash\ntransport.sudo('echo Hello world');\n\n// will run echo 'echo Hello world' | sudo -u www -i bash\ntransport.sudo('echo Hello world', {user: 'www'});\n\n// further options passed (see `exec()`)\ntransport.sudo('echo Hello world', {user: 'www', silent: true, failsafe: true});\n```\n\nFlightplan's `sudo()` requires a certain setup on your host. In order to\nmake things work on a typical Ubuntu installation, follow these rules:\n\n```bash\n# Scenario:\n# 'pstadler' is the user for connecting to the host and 'www' is the user\n# under which you want to execute commands with sudo.\n\n# 1. 'pstadler' has to be in the sudo group:\n$ groups pstadler\npstadler : pstadler sudo\n\n# 2. 'pstadler' needs to be able to run sudo -u 'www' without a password.\n# In order to do this, add the following line to /etc/sudoers:\npstadler ALL=(www) NOPASSWD: ALL\n\n# 3. user 'www' needs to have a login shell (e.g. bash, sh, zsh, ...)\n$ cat /etc/passwd | grep www\nwww:x:1002:1002::/home/www:/bin/bash   # GOOD\nwww:x:1002:1002::/home/www:/bin/false  # BAD\n```\n\n### transport.transfer(files, remoteDir[, options]) → [results]\n\nCopy a list of files to the current target's remote host(s) using\n`rsync` with the SSH protocol. File transfers are executed in parallel.\n After finishing all transfers, an array containing results from\n`transport.exec()` is returned. This method is only available on local\nflights.\n\n```javascript\nvar files = ['path/to/file1', 'path/to/file2'];\nlocal.transfer(files, '/tmp/foo');\n```\n\n#### Files argument\nTo make things more comfortable, the `files` argument doesn't have to be\npassed as an array. Results from previous commands and zero-terminated\nstrings are handled as well:\n\n```javascript\n// use result from a previous command\nvar files = local.git('ls-files', {silent: true}); // get list of files under version control\nlocal.transfer(files, '/tmp/foo');\n\n// use zero-terminated result from a previous command\nvar files = local.exec('(git ls-files -z;find node_modules -type f -print0)', {silent: true});\nlocal.transfer(files, '/tmp/foo');\n\n// use results from multiple commands\nvar result1 = local.git('ls-files', {silent: true}).stdout.split('\\n');\nvar result2 = local.find('node_modules -type f', {silent: true}).stdout.split('\\n');\nvar files = result1.concat(result2);\nfiles.push('path/to/another/file');\nlocal.transfer(files, '/tmp/foo');\n```\n\n`transfer()` will use the current host's username defined with\n`target()` unless `fly` is called with the `-u|--username` option.\nIn this case the latter will be used. If debugging is enabled\n(either with `target()` or with `fly --debug`), `rsync` is executed\nin verbose mode (`-vv`).\n\n### transport.prompt(message[, options]) → input\n\nPrompt for user input.\n\n```javascript\nvar input = transport.prompt('Are you sure you want to continue? [yes]');\nif(input.indexOf('yes') === -1) {\n  plan.abort('User canceled flight');\n}\n\n// prompt for password (with UNIX-style hidden input)\nvar password = transport.prompt('Enter your password:', { hidden: true });\n\n// prompt when deploying to a specific target\nif(plan.runtime.target === 'production') {\n  var input = transport.prompt('Ready for deploying to production? [yes]');\n  if(input.indexOf('yes') === -1) {\n    plan.abort('User canceled flight');\n  }\n}\n```\n\n### transport.waitFor(fn(done)) → {} mixed\n\nExecute a function and return after the callback `done` is called.\nThis is used for running asynchronous functions in a synchronous way.\n\nThe callback takes an optional argument which is then returned by\n`waitFor()`.\n\n```javascript\nvar result = transport.waitFor(function(done) {\n  require('node-notifier').notify({\n      message: 'Hello World'\n    }, function(err, response) {\n      done(err || 'sent!');\n    });\n});\nconsole.log(result); // 'sent!'\n```\n\n### transport.with(command|options[, options], fn)\n\nExecute commands with a certain context.\n\n```javascript\ntransport.with('cd /tmp', function() {\n  transport.ls('-al'); // 'cd /tmp && ls -al'\n});\n\ntransport.with({silent: true, failsafe: true}, function() {\n  transport.ls('-al'); // output suppressed, fail safely\n});\n\ntransport.with('cd /tmp', {silent: true}, function() {\n  transport.ls('-al'); // 'cd /tmp && ls -al', output suppressed\n});\n```\n\n### transport.silent()\n\nWhen calling `silent()` all subsequent commands are executed without\nprinting their output to stdout until `verbose()` is called.\n\n```javascript\ntransport.ls(); // output will be printed to stdout\ntransport.silent();\ntransport.ls(); // output won't be printed to stdout\n```\n\n### transport.verbose()\n\nCalling `verbose()` reverts the behavior introduced with `silent()`.\nOutput of commands will be printed to stdout.\n\n```javascript\ntransport.silent();\ntransport.ls(); // output won't be printed to stdout\ntransport.verbose();\ntransport.ls(); // output will be printed to stdout\n```\n\n### transport.failsafe()\n\nWhen calling `failsafe()`, all subsequent commands are allowed to fail\nuntil `unsafe()` is called. In other words, the flight will continue\neven if the return code of the command is not `0`. This is helpful if\neither you expect a command to fail or their nature is to return a\nnon-zero exit code.\n\n```javascript\ntransport.failsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\ntransport.log('Previous command failed, but flight was not aborted');\n```\n\n### transport.unsafe()\n\nCalling `unsafe()` reverts the behavior introduced with `failsafe()`.\nThe flight will be aborted if a subsequent command fails (i.e. returns\na non-zero exit code). This is the default behavior.\n\n```javascript\ntransport.failsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\ntransport.log('Previous command failed, but flight was not aborted');\ntransport.unsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\n// flight aborted\n```\n\n### transport.log(message)\n\nPrint a message to stdout. Flightplan takes care that the message\nis formatted correctly within the current context.\n\n```javascript\ntransport.log('Copying files to remote hosts');\n```\n\n### transport.debug(message)\n\nPrint a debug message to stdout if debug mode is enabled. Flightplan\ntakes care that the message is formatted correctly within the current\ncontext.\n\n```javascript\ntransport.debug('Copying files to remote hosts');\n```\n\n<!-- End ../lib/transport/index.js -->\n\n<!-- ENDDOCS -->\n\n[npm-url]: https://npmjs.com/package/flightplan\n[npm-version-image]: https://img.shields.io/npm/v/flightplan.svg?style=flat-square\n[npm-downloads-image]: https://img.shields.io/npm/dm/flightplan.svg?style=flat-square\n\n[dependencies-url]: https://david-dm.org/pstadler/flightplan\n[dependencies-image]: https://david-dm.org/pstadler/flightplan.svg?style=flat-square\n\n[build-status-url]: https://travis-ci.org/pstadler/flightplan\n[build-status-image]: https://img.shields.io/travis/pstadler/flightplan/master.svg?style=flat-square\n\n[coverage-url]: https://coveralls.io/github/pstadler/flightplan?branch=master\n[coverage-image]: https://img.shields.io/coveralls/pstadler/flightplan/master.svg?style=flat-square\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pstadler/flightplan.git"
  },
  "scripts": {
    "coverage": "rm -rf ./coverage; ./node_modules/.bin/istanbul cover --dir coverage/lib ./node_modules/.bin/_mocha -- -R spec; ./node_modules/.bin/istanbul report",
    "coverage-lcov": "rm -rf ./coverage; ./node_modules/.bin/istanbul cover --dir coverage/lib --report lcovonly ./node_modules/.bin/_mocha -- -R spec; ./node_modules/.bin/istanbul report lcovonly",
    "coveralls": "npm run coverage-lcov && cat ./coverage/lcov.info | ./node_modules/.bin/coveralls",
    "docs": "cd ./docs; node generate.js",
    "lint": "eslint .",
    "test": "mocha"
  },
  "version": "0.6.17"
}
